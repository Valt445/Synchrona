#version 450
layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D image;

layout (push_constant) uniform PushConstants {
    vec4 color1;   // nebula base color
    vec4 color2;   // nebula secondary color
    float time;    // elapsed time
} pc;

// Hash for randomness
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(41.0, 289.0))) * 45758.5453);
}

// Smooth noise
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

// fBm (fractal brownian motion)
float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    for (int i = 0; i < 5; i++) {
        v += a * noise(p);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size  = imageSize(image);
    vec2 uv     = vec2(pixel) / vec2(size);

    // Center and scale
    vec2 p = uv * 4.0 - vec2(2.0);

    // Nebula pattern with animated fbm
    float nebula = fbm(p * 1.5 + pc.time * 0.05);
    nebula = pow(nebula, 2.0); // make contrasty

    // Starfield
    float starVal = hash(uv * size);
    float stars = step(0.998, starVal); // random tiny stars
    stars *= (0.5 + 0.5 * sin(pc.time * 10.0 + starVal * 100.0)); // twinkle

    // Color blend
    vec3 nebulaColor = mix(pc.color1.rgb, pc.color2.rgb, nebula);
    vec3 finalColor = nebulaColor + vec3(stars);

    imageStore(image, pixel, vec4(finalColor, 1.0));
}
